<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Action Rogue RPG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #0a0a0a;
            color: #f0f0f0;
            overflow: hidden;
        }
        .game-container {
            display: grid;
            /* Mobile-first: stacked layout */
            grid-template-columns: 1fr;
            grid-template-rows: auto 1fr; /* Canvas auto height, panel fills rest */
            gap: 1rem;
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem;
            height: 100vh; /* Constrain height to viewport */
        }
        canvas {
            background: #111;
            border-radius: 0.5rem;
            border: 2px solid #444;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            width: 100%;
            height: auto;
            aspect-ratio: 40 / 30; /* Maintain aspect ratio */
        }
        .ui-panel {
            background: #2a2a2a;
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 2px solid #444;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            overflow-y: auto;
        }
        /* Medium screens and up (side-by-side layout) */
        @media (min-width: 1024px) {
            .game-container {
                grid-template-columns: 3fr 1fr;
                grid-template-rows: 1fr; /* Reset to single row layout */
                padding: 1rem;
                height: calc(100vh - 2rem);
            }
             .ui-panel {
                max-height: calc(100vh - 4rem);
            }
        }
        .ui-panel h2, .ui-panel h3 {
            color: #ffc700;
            border-bottom: 2px solid #444;
            padding-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        h3 { font-size: 1rem; margin-bottom: 0.25rem; }
        .log-container { background: #111; height: 120px; overflow-y: scroll; padding: 0.5rem; border-radius: 0.5rem; font-size: 0.65rem; line-height: 1.5; border: 1px solid #333; }
        .stat-bar { width: 100%; background: #444; border-radius: 0.25rem; overflow: hidden; height: 1.25rem; border: 1px solid #111; }
        .stat-bar-fill { height: 100%; transition: width 0.2s ease-in-out; text-align: center; font-size: 0.75rem; line-height: 1.25rem; color: #000; font-weight: bold; }
        .hp-bar { background-color: #d9534f; }
        .xp-bar { background-color: #5bc0de; }
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .modal-content { background: #2a2a2a; padding: 2rem; border-radius: 0.5rem; border: 2px solid #444; text-align: center; max-width: 800px; width: 90%; max-height: 90vh; overflow-y: auto;}
        .char-card { border: 2px solid #444; padding: 1.5rem; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s ease-in-out; }
        .char-card:hover { background: #444; border-color: #ffc700; }
        .btn { background-color: #ffc700; color: #1a1a1a; padding: 0.75rem 1.5rem; border: none; border-radius: 0.5rem; font-family: 'Press Start 2P', cursive; cursor: pointer; text-transform: uppercase; transition: background-color 0.2s; }
        .btn:hover { background-color: #ffdd57; }
        .btn-buy, .btn-unlock { background-color: #4CAF50; color: white; }
        .btn-buy:hover, .btn-unlock:hover { background-color: #66bb6a; }
        .btn-equip { background-color: #3498db; color: white; padding: 0.25rem 0.5rem; font-size: 0.6rem; }
        .btn-equip:hover { background-color: #5dade2; }
        .skill-ready { color: #4CAF50; }
        .skill-cooldown { color: #d9534f; }
        .controls { font-size: 0.7rem; line-height: 1.5; margin-top: 1rem; border-top: 2px solid #444; padding-top: 1rem; }
        .inventory-list { max-height: 200px; overflow-y: auto; background: #111; padding: 0.5rem; border-radius: 0.5rem; }
        .inter-level-section { background: #1a1a1a; padding: 1rem; border-radius: 0.5rem; margin-top: 1rem; }
    </style>
</head>
<body class="bg-gray-900 text-white p-4">

    <div id="character-selection" class="modal">
        <div class="modal-content">
            <h1 class="text-3xl mb-6 text-yellow-400">Choose your class</h1>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div id="select-warrior" class="char-card"><h3 class="text-xl text-red-500">Warrior</h3><p class="text-sm mt-2">Durable melee fighter. Specializes in Axes for stunning blows.</p></div>
                <div id="select-mage" class="char-card"><h3 class="text-xl text-blue-500">Mage</h3><p class="text-sm mt-2">Ranged spellcaster. Wields Staves to empower spells.</p></div>
                <div id="select-rogue" class="char-card"><h3 class="text-xl text-green-500">Rogue</h3><p class="text-sm mt-2">Elusive assassin. Uses Daggers to make enemies bleed.</p></div>
            </div>
        </div>
    </div>
    <div id="game-over-screen" class="modal hidden"><div class="modal-content"><h1 class="text-4xl mb-4 text-red-500">You Died</h1><p class="mb-6">The dungeon claims another soul. You reached floor <span id="final-level">1</span>.</p><button id="restart-button" class="btn">Try Again</button></div></div>
    <div id="inventory-screen" class="modal hidden"><div class="modal-content"><h1 class="text-3xl mb-6 text-yellow-400">Inventory</h1><div class="grid grid-cols-2 gap-4 text-left"><div><h3 class="text-lg mb-2">Equipped</h3><p><b>Weapon:</b> <span id="inv-weapon-name"></span></p><p><b>Armor:</b> <span id="inv-armor-name"></span></p></div><div><h3 class="text-lg mb-2">Backpack</h3><div id="inventory-list" class="inventory-list"></div></div></div><button id="close-inventory" class="btn mt-8">Close</button></div></div>
    <div id="level-clear-screen" class="modal hidden"><div class="modal-content"><h1 class="text-3xl mb-6 text-yellow-400">Floor Cleared!</h1><p class="mb-4">Prepare for the next challenge. Spend your rewards wisely.</p><div class="grid grid-cols-1 md:grid-cols-2 gap-6 text-left"><div class="inter-level-section"> <h2 class="text-2xl mb-4 text-center">Skill Tree</h2> <p class="text-center mb-2">Skill Points: <span id="skill-points-value">0</span></p> <div id="skill-unlock-options" class="space-y-3"></div></div><div class="inter-level-section"> <h2 class="text-2xl mb-4 text-center">Merchant's Wares</h2> <p class="text-center mb-2">Your Gold: <span id="shop-gold-value">0</span></p> <div id="shop-item-options" class="space-y-3"></div></div></div><button id="next-level-button" class="btn mt-8">Descend to Floor <span id="next-floor-number">2</span></button></div></div>

    <div class="game-container">
        <div><canvas id="gameCanvas"></canvas></div>
        <div class="ui-panel">
            <h2 id="player-class">Class</h2>
            <div><p>Level: <span id="player-level">1</span> | Floor: <span id="dungeon-level">1</span></p></div>
            <div><p>HP: <span id="hp-value">100</span>/<span id="max-hp-value">100</span></p><div class="stat-bar"><div id="hp-bar" class="stat-bar-fill hp-bar"></div></div></div>
            <div><p>XP: <span id="xp-value">0</span>/<span id="xp-next-value">100</span></p><div class="stat-bar"><div id="xp-bar" class="stat-bar-fill xp-bar" style="width: 0%;"></div></div></div>
            <div><h3>Character Stats</h3><p>Attack: <span id="attack-stat">10</span></p><p>Defense: <span id="defense-stat">5</span></p></div>
            <div><h3>Equipment</h3><p>Weapon: <span id="weapon-name">Bare Hands</span> (<span id="weapon-damage">1-4</span>)</p><p>Armor: <span id="armor-name">Rags</span> (<span id="armor-defense">0</span>)</p></div>
            <div id="specialty-info-container" class="hidden"><h3>Specialty</h3><p id="specialty-info" class="text-xs"></p></div>
            <div><h3>Inventory</h3><p>Gold: <span id="gold-value">0</span> | Potions: <span id="potions-value">1</span></p></div>
            <div><h3>Abilities</h3><div id="skill-info" class="text-xs space-y-1"></div></div>
            <h2 class="mt-2">Log</h2>
            <div id="log" class="log-container"><p>Welcome to the dungeon!</p></div>
            <div class="controls">
                <p><b>Move:</b> WASD/Arrows</p>
                <p><b>Attack:</b> Spacebar</p>
                <p><b>Skills:</b> 1, 2, 3</p>
                <p><b>Potion:</b> P | <b>Inv:</b> I</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const TILE_SIZE = 32;
        const MAP_WIDTH_TILES = 40;
        const MAP_HEIGHT_TILES = 30;

        canvas.width = TILE_SIZE * MAP_WIDTH_TILES;
        canvas.height = TILE_SIZE * MAP_HEIGHT_TILES;

        let player, map, enemies, items, particles, projectiles;
        let gameLog = [];
        let dungeonLevel = 1;
        let lastTime = 0;
        let keysDown = {};
        let isPaused = false;
        
        const SYMBOLS = { floor: { char: '¬∑', color: '#3a3a3a' }, wall: { char: '#', color: '#8a8a8a' }, player: { Warrior: 'ü§∫', Mage: 'üßô', Rogue: 'üë§' }, potion: { char: 'üß™', color: '#5bc0de' }, gold: { char: 'üí∞', color: '#f0ad4e' }, weapon: { char: '‚öîÔ∏è', color: '#cccccc' }, armor: { char: 'üõ°Ô∏è', color: '#7f8c8d' } };
        const ENEMY_SYMBOLS = { goblin: { char: 'üëπ', color: '#6ab04c' }, orc: { char: 'üë∫', color: '#f0932b' }, skeleton: { char: 'üíÄ', color: '#f5f6fa' }, troll: { char: 'ü¶ç', color: '#be2edd' } };
        
        const WEAPONS = {
            'Dagger': { name: 'Dagger', type: 'Dagger', baseDamage: 4, cost: 50 },
            'Sword': { name: 'Sword', type: 'Sword', baseDamage: 6, cost: 60 },
            'Staff': { name: 'Staff', type: 'Staff', baseDamage: 5, cost: 55 },
            'Iron Axe': { name: 'Iron Axe', type: 'Axe', baseDamage: 10, cost: 100 },
            'Magic Wand': { name: 'Magic Wand', type: 'Staff', baseDamage: 8, cost: 90 },
            'Poisoned Dirk': { name: 'Poisoned Dirk', type: 'Dagger', baseDamage: 6, cost: 120 },
            'Greatsword': { name: 'Greatsword', type: 'Sword', baseDamage: 12, cost: 150 },
            'Battle Axe': { name: 'Battle Axe', type: 'Axe', baseDamage: 14, cost: 180 },
        };
        const ARMOR = { 'Leather Armor': { name: 'Leather Armor', type: 'Armor', baseDefense: 2, cost: 70 }, 'Chainmail': { name: 'Chainmail', type: 'Armor', baseDefense: 4, cost: 120 }, 'Steel Plate': { name: 'Steel Plate', type: 'Armor', baseDefense: 6, cost: 200 }, 'Mage Robes': { name: 'Mage Robes', type: 'Armor', baseDefense: 1, cost: 60 } };
        
        const ALL_SKILLS = { 
            'Whirlwind': { name: 'Whirlwind', description: 'Damage all nearby enemies.', cooldown: 8, key: '2' }, 
            'War Stomp': { name: 'War Stomp', description: 'Stun and damage nearby foes.', cooldown: 10, key: '3', stunDuration: 1.5 }, 
            'Power Strike': { name: 'Power Strike', description: 'Next attack deals double damage.', cooldown: 5, key: '1' }, 
            'Teleport': { name: 'Teleport', description: 'Blink a short distance.', cooldown: 10, range: 5, key: '2' }, 
            'Frost Nova': { name: 'Frost Nova', description: 'Slow and damage all nearby enemies.', cooldown: 12, key: '3', slowDuration: 4 }, 
            'Fireball': { name: 'Fireball', description: 'Launch a fiery projectile.', cooldown: 4, range: 6, key: '1' },
            'Vanish': { name: 'Vanish', description: 'Become invisible for a short time.', cooldown: 12, duration: 3, key: '2' }, 
            'Poison Blade': { name: 'Poison Blade', description: 'Your attacks poison enemies.', cooldown: 15, duration: 5, key: '3' },
            'Dash': { name: 'Dash', description: 'Quickly move a short distance.', cooldown: 5, key: '1' },
         };

        const PLAYER_CLASSES = { 
            Warrior: { hp: 150, attack: 12, defense: 8, speed: 200, weapon: JSON.parse(JSON.stringify(WEAPONS['Sword'])), startingSkills: [ALL_SKILLS['Power Strike']], availableSkills: [ALL_SKILLS['Whirlwind'], ALL_SKILLS['War Stomp']] }, 
            Mage: { hp: 90, attack: 8, defense: 4, speed: 220, weapon: JSON.parse(JSON.stringify(WEAPONS['Staff'])), startingSkills: [ALL_SKILLS['Fireball']], availableSkills: [ALL_SKILLS['Teleport'], ALL_SKILLS['Frost Nova']] }, 
            Rogue: { hp: 110, attack: 10, defense: 6, speed: 250, weapon: JSON.parse(JSON.stringify(WEAPONS['Dagger'])), startingSkills: [ALL_SKILLS['Dash']], availableSkills: [ALL_SKILLS['Vanish'], ALL_SKILLS['Poison Blade']] } 
        };
        const ENEMY_TYPES = { goblin: { name: 'Goblin', hp: 20, attack: 5, defense: 2, xp: 10, gold: 5, speed: 100, symbol: ENEMY_SYMBOLS.goblin, attackRange: 40, attackCooldown: 2, aggroRange: 200 }, orc: { name: 'Orc', hp: 40, attack: 10, defense: 5, xp: 25, gold: 15, speed: 80, symbol: ENEMY_SYMBOLS.orc, attackRange: 50, attackCooldown: 2.5, aggroRange: 250 }, skeleton: { name: 'Skeleton', hp: 30, attack: 8, defense: 3, xp: 15, gold: 10, speed: 90, symbol: ENEMY_SYMBOLS.skeleton, attackRange: 45, attackCooldown: 2.2, aggroRange: 220 }, troll: { name: 'Troll', hp: 80, attack: 15, defense: 8, xp: 50, gold: 30, speed: 60, symbol: ENEMY_SYMBOLS.troll, attackRange: 60, attackCooldown: 3, aggroRange: 300 } };
        
        function initGame(className) {
            document.getElementById('character-selection').classList.add('hidden');
            const classData = PLAYER_CLASSES[className];
            player = {
                ...classData,
                w: TILE_SIZE * 0.8, h: TILE_SIZE * 0.8,
                className: className,
                hp: classData.hp, maxHp: classData.hp,
                level: 1, xp: 0, xpToNextLevel: 100,
                gold: 0, potions: 1,
                attackTimer: 0,
                armor: null,
                inventory: [],
                skills: classData.startingSkills.map(s => ({...s, currentCooldown: 0 })),
                skillTree: [...classData.availableSkills],
                skillPoints: 0,
                statusEffects: {},
            };
            dungeonLevel = 1;
            particles = []; projectiles = []; gameLog = ['Welcome, brave ' + className + '!'];
            startLevel();
        }
        
        function startLevel() {
            generateDungeon();
            const startRoom = map.rooms[0];
            player.x = (startRoom.x + startRoom.w / 2) * TILE_SIZE;
            player.y = (startRoom.y + startRoom.h / 2) * TILE_SIZE;
            player.hp = player.maxHp; // Full heal between levels
            updateUI();
            isPaused = false;
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function generateDungeon() {
            map = generateMap();
            enemies = []; items = [];
            const enemyCount = 2 + dungeonLevel * 2;
            for (let i = 0; i < enemyCount; i++) {
                const room = map.rooms[Math.floor(Math.random() * map.rooms.length)];
                const x = (room.x + Math.random() * room.w) * TILE_SIZE;
                const y = (room.y + Math.random() * room.h) * TILE_SIZE;
                const enemyPool = [ENEMY_TYPES.goblin, ENEMY_TYPES.skeleton];
                if (dungeonLevel > 2) enemyPool.push(ENEMY_TYPES.orc); if (dungeonLevel > 4) enemyPool.push(ENEMY_TYPES.troll);
                const type = {...enemyPool[Math.floor(Math.random() * enemyPool.length)]};
                enemies.push({ ...type, x, y, w: TILE_SIZE * 0.8, h: TILE_SIZE * 0.8, maxHp: type.hp, state: 'idle', attackTimer: 0, statusEffects: {} });
            }
            
            // Add some potions and gold
             for (let i = 1; i < map.rooms.length; i++) {
                const room = map.rooms[i];
                 if (Math.random() < 0.2) { 
                     const x = (room.x + Math.floor(Math.random() * room.w)) * TILE_SIZE + TILE_SIZE/2;
                     const y = (room.y + Math.floor(Math.random() * room.h)) * TILE_SIZE + TILE_SIZE/2;
                     items.push({ type: 'potion', x, y, w:TILE_SIZE, h:TILE_SIZE });
                 }
                  if (Math.random() < 0.3) { 
                     const x = (room.x + Math.floor(Math.random() * room.w)) * TILE_SIZE + TILE_SIZE/2;
                     const y = (room.y + Math.floor(Math.random() * room.h)) * TILE_SIZE + TILE_SIZE/2;
                     items.push({ type: 'gold', value: Math.floor(Math.random() * 20) + (5 * dungeonLevel), x, y, w:TILE_SIZE, h:TILE_SIZE });
                 }
             }
        }
        
        function generateMap() {
            let mapGrid = Array(MAP_HEIGHT_TILES).fill(0).map(() => Array(MAP_WIDTH_TILES).fill(1)); // 1 is wall
            let rooms = [];
            const maxRooms = 20, minRoomSize = 4, maxRoomSize = 10;
            for (let r = 0; r < maxRooms; r++) {
                let w = Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1)) + minRoomSize;
                let h = Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1)) + minRoomSize;
                let x = Math.floor(Math.random() * (MAP_WIDTH_TILES - w - 2)) + 1;
                let y = Math.floor(Math.random() * (MAP_HEIGHT_TILES - h - 2)) + 1;
                const newRoom = { x, y, w, h };
                if (!rooms.some(otherRoom => rectsIntersect(newRoom, otherRoom, 2))) {
                    createRoom(mapGrid, newRoom);
                    if (rooms.length > 0) {
                        const prevCenter = { x: rooms[rooms.length-1].x + Math.floor(rooms[rooms.length-1].w / 2), y: rooms[rooms.length-1].y + Math.floor(rooms[rooms.length-1].h / 2) };
                        const newCenter = { x: newRoom.x + Math.floor(newRoom.w / 2), y: newRoom.y + Math.floor(newRoom.h / 2) };
                        if (Math.random() > 0.5) { createHTunnel(mapGrid, prevCenter.x, newCenter.x, prevCenter.y); createVTunnel(mapGrid, prevCenter.y, newCenter.y, newCenter.x); } 
                        else { createVTunnel(mapGrid, prevCenter.y, newCenter.y, prevCenter.x); createHTunnel(mapGrid, prevCenter.x, newCenter.x, newCenter.y); }
                    }
                    rooms.push(newRoom);
                }
            }
            return { grid: mapGrid, rooms };
        }
        function rectsIntersect(r1, r2, padding=0) { return r1.x < r2.x + r2.w + padding && r1.x + r1.w + padding > r2.x && r1.y < r2.y + r2.h + padding && r1.y + r1.h + padding > r2.y; }
        function createRoom(map, room) { for (let y = room.y; y < room.y + room.h; y++) for (let x = room.x; x < room.x + room.w; x++) map[y][x] = 0; }
        function createHTunnel(map, x1, x2, y) { for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {map[y][x] = 0; if(map[y-1]) map[y-1][x]=0; if(map[y+1]) map[y+1][x]=0;} }
        function createVTunnel(map, y1, y2, x) { for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {map[y][x] = 0; if(map[y][x-1]) map[y][x-1]=0; if(map[y][x+1]) map[y][x+1]=0;} }

        function isWall(x, y) {
            const tileX = Math.floor(x / TILE_SIZE);
            const tileY = Math.floor(y / TILE_SIZE);
            if (tileX < 0 || tileX >= MAP_WIDTH_TILES || tileY < 0 || tileY >= MAP_HEIGHT_TILES) return true;
            return map.grid[tileY][tileX] === 1;
        }

        function update(dt) {
            // Player movement
            let dx = 0, dy = 0;
            if (keysDown['w'] || keysDown['ArrowUp']) dy -= 1;
            if (keysDown['s'] || keysDown['ArrowDown']) dy += 1;
            if (keysDown['a'] || keysDown['ArrowLeft']) dx -= 1;
            if (keysDown['d'] || keysDown['ArrowRight']) dx += 1;

            if (dx !== 0 || dy !== 0) {
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                const moveX = (dx / magnitude) * player.speed * dt;
                const moveY = (dy / magnitude) * player.speed * dt;
                
                const nextX = player.x + moveX;
                if (!isWall(nextX, player.y) && !isWall(nextX + player.w, player.y) && !isWall(nextX, player.y+player.h) && !isWall(nextX+player.w, player.y+player.h)) player.x = nextX;
                const nextY = player.y + moveY;
                if (!isWall(player.x, nextY) && !isWall(player.x+player.w, nextY) && !isWall(player.x, nextY+player.h) && !isWall(player.x+player.w, nextY+player.h)) player.y = nextY;
            }
            
            // Player attack
            player.attackTimer = Math.max(0, player.attackTimer - dt);
            if (keysDown[' '] && player.attackTimer === 0) {
                player.attackTimer = 0.5; // attack speed
                createParticleEffect(player.x + player.w/2, player.y + player.h/2, '#ffc700', { count: 12, speed: 3, life: 0.3, size: 3 });
                enemies.forEach(enemy => {
                    if (distance(player, enemy) < 80) {
                       let damageMultiplier = player.statusEffects.powerStrike ? 2 : 1;
                       if(player.statusEffects.powerStrike) {
                          addLog("POWER STRIKE!");
                          player.skills.find(s=>s.name === 'Power Strike').currentCooldown = player.skills.find(s=>s.name === 'Power Strike').cooldown;
                          delete player.statusEffects.powerStrike;
                       }
                       dealDamage(player, enemy, damageMultiplier);
                    }
                });
            }
            
            // Player skills & status effects
            player.skills.forEach(skill => {
                skill.currentCooldown = Math.max(0, skill.currentCooldown - dt);
                if(keysDown[skill.key] && skill.currentCooldown === 0) useSkill(skill.name);
            });
            if (player.statusEffects.invisible > 0) player.statusEffects.invisible -= dt;
            if (player.statusEffects.poisonBlade > 0) player.statusEffects.poisonBlade -= dt;


            updateEnemies(dt);
            updateProjectiles(dt);
            checkCollisions();
            updateParticles(dt);

            updateUI();
        }

        function dealDamage(attacker, defender, multiplier = 1, isPoison=false) {
            let totalDefense = defender.defense;
            if (defender === player && player.armor) {
                totalDefense += player.armor.baseDefense;
            }
            let baseDamage = (attacker === player) ? player.weapon.baseDamage : attacker.attack;
            
            // Mage Specialty: Spell Power
            if (attacker.className === 'Mage' && attacker.weapon.type === 'Staff' && isPoison === false) { 
                baseDamage *= 1.2; 
            }

            let damage = Math.max(1, Math.floor(baseDamage - totalDefense)) * multiplier;
            if (attacker.className === 'Rogue' && Math.random() < 0.2 && !isPoison) { damage *= 2; addLog("Critical hit!"); }
            
            if (attacker === player && player.statusEffects.poisonBlade > 0 && !isPoison) {
                defender.statusEffects.poisoned = { duration: 3, damage: baseDamage * 0.5 };
                addLog(`${defender.name} is poisoned!`);
            }
            
            // Weapon Specialties application
            if (attacker === player && !isPoison) {
                if (attacker.className === 'Warrior' && attacker.weapon.type === 'Axe' && Math.random() < 0.25) {
                    defender.statusEffects.stunned = 0.5; 
                    addLog(`You stunned ${defender.name} with your axe!`);
                }
                if (attacker.className === 'Rogue' && attacker.weapon.type === 'Dagger' && !defender.statusEffects.bleeding) {
                    defender.statusEffects.bleeding = { duration: 4, damagePerSecond: player.weapon.baseDamage * 0.3, lastTick: 0 };
                    addLog(`${defender.name} is bleeding!`);
                }
            }

            defender.hp -= damage;
            createParticleEffect(defender.x + defender.w/2, defender.y + defender.h/2, isPoison ? '#7cfc00' : '#ff4d4d', {count: 15, speed: 4, size: 4});
            if(!isPoison) addLog(`${attacker.className || attacker.name} hits ${defender.name} for ${Math.round(damage)} damage.`);

            if (defender.hp <= 0) {
                if (defender === player) { gameOver(); }
                else {
                    addLog(`You defeated the ${defender.name}!`);
                    player.gold += defender.gold;
                    gainXP(defender.xp);
                    enemies = enemies.filter(e => e !== defender);
                    if(enemies.length === 0){
                        showLevelClearScreen();
                    }
                }
            }
        }
        
        function updateEnemies(dt) {
            enemies.forEach(enemy => {
                enemy.statusEffects.lastTick = (enemy.statusEffects.lastTick || 0) + dt;
                // Status effects
                if (enemy.statusEffects.stunned > 0) { enemy.statusEffects.stunned -= dt; return; }
                if (enemy.statusEffects.poisoned) {
                    enemy.statusEffects.poisoned.duration -= dt;
                    dealDamage(player, enemy, 1, true); // apply poison damage
                    if(enemy.statusEffects.poisoned.duration <=0) delete enemy.statusEffects.poisoned;
                }
                if (enemy.statusEffects.bleeding && enemy.statusEffects.lastTick >= 1) {
                    enemy.statusEffects.bleeding.duration -= 1;
                    const bleedDamage = Math.round(enemy.statusEffects.bleeding.damagePerSecond);
                    enemy.hp -= bleedDamage;
                    addLog(`${enemy.name} bleeds for ${bleedDamage} damage.`);
                    createParticleEffect(enemy.x + enemy.w/2, enemy.y + enemy.h/2, '#8b0000', {count: 8, speed: 1, life: 0.4});
                    enemy.statusEffects.lastTick = 0;
                    if(enemy.statusEffects.bleeding.duration <= 0) delete enemy.statusEffects.bleeding;
                }
                let currentSpeed = enemy.speed;
                if (enemy.statusEffects.slowed > 0) { currentSpeed *= 0.5; enemy.statusEffects.slowed -= dt; }

                const distToPlayer = distance(enemy, player);
                if (player.statusEffects.invisible > 0 || distToPlayer > enemy.aggroRange) enemy.state = 'idle';
                else if (distToPlayer <= enemy.attackRange) enemy.state = 'attacking';
                else enemy.state = 'chasing';

                enemy.attackTimer = Math.max(0, enemy.attackTimer - dt);

                if (enemy.state === 'chasing') {
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    const moveX = Math.cos(angle) * currentSpeed * dt;
                    const moveY = Math.sin(angle) * currentSpeed * dt;
                    if (!isWall(enemy.x + moveX, enemy.y)) enemy.x += moveX;
                    if (!isWall(enemy.x, enemy.y + moveY)) enemy.y += moveY;
                } else if (enemy.state === 'attacking' && enemy.attackTimer === 0) {
                    enemy.attackTimer = enemy.attackCooldown;
                    dealDamage(enemy, player);
                }
            });
        }
        
        function updateProjectiles(dt) {
            for(let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
                if (isWall(p.x, p.y) || p.life <= 0) { projectiles.splice(i, 1); continue; }
                for (const enemy of enemies) {
                    if (rectsIntersect(p, enemy)) {
                        dealDamage(player, enemy, 1, true); // Projectile damage is considered 'magical'
                        createParticleEffect(p.x, p.y, 'red', 15);
                        projectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }

        function useSkill(skillName) {
            const skill = player.skills.find(s => s.name === skillName);
            if (!skill || skill.currentCooldown > 0) return;
            skill.currentCooldown = skill.cooldown;
            
            let skillDamageMultiplier = 1;
            if (player.className === 'Mage' && player.weapon.type === 'Staff') {
                skillDamageMultiplier = 1.2;
            }
            
            switch(skillName) {
                case 'Whirlwind': addLog("You unleash a Whirlwind!"); createParticleEffect(player.x + player.w/2, player.y + player.h/2, '#ccc', { count: 60, speed: 9, life: 0.8, size: 5 }); enemies.forEach(enemy => { if(distance(player, enemy) < 120) dealDamage(player, enemy, 1.5); }); break;
                case 'Power Strike': player.statusEffects.powerStrike = true; addLog('Your next attack is a Power Strike!'); break;
                case 'War Stomp': addLog('You stomp the ground with immense force!'); createParticleEffect(player.x + player.w/2, player.y + player.h/2, '#d2b48c', { count: 40, speed: 5, life: 1 }); enemies.forEach(e => { if(distance(player, e) < 100) { dealDamage(player, e, 0.5); e.statusEffects.stunned = skill.stunDuration; }}); break;
                case 'Fireball': const target = findNearestEnemy(skill.range * TILE_SIZE); if (target) { const angle = Math.atan2(target.y - player.y, target.x - player.x); projectiles.push({ x: player.x, y: player.y, w:10, h:10, vx: Math.cos(angle) * 300, vy: Math.sin(angle) * 300, life: 2, color: 'orange' }); } else { addLog('No enemy in range for Fireball!'); skill.currentCooldown=0; } break;
                case 'Teleport': let angle = Math.atan2((keysDown['s']||keysDown['ArrowDown']?1:0) - (keysDown['w']||keysDown['ArrowUp']?1:0), (keysDown['d']||keysDown['ArrowRight']?1:0) - (keysDown['a']||keysDown['ArrowLeft']?1:0)); if(isNaN(angle)) angle = 0; const tpX = player.x + Math.cos(angle) * skill.range * TILE_SIZE; const tpY = player.y + Math.sin(angle) * skill.range * TILE_SIZE; if(!isWall(tpX, tpY)) { player.x = tpX; player.y = tpY; createParticleEffect(tpX, tpY, '#9400d3', {count: 30}); } else { addLog('Cannot teleport into a wall!'); skill.currentCooldown=0; } break;
                case 'Frost Nova': addLog('A blast of cold erupts from you!'); createParticleEffect(player.x + player.w/2, player.y + player.h/2, '#00ffff', { count: 70, speed: 7, life: 1.2, size: 6 }); enemies.forEach(e => { if(distance(player,e) < 150) { dealDamage(player, e, 0.8 * skillDamageMultiplier, true); e.statusEffects.slowed = skill.slowDuration; }}); break;
                case 'Dash': let dashAngle = Math.atan2((keysDown['s']||keysDown['ArrowDown']?1:0) - (keysDown['w']||keysDown['ArrowUp']?1:0), (keysDown['d']||keysDown['ArrowRight']?1:0) - (keysDown['a']||keysDown['ArrowLeft']?1:0)); if(isNaN(dashAngle)) dashAngle = 0; player.x += Math.cos(dashAngle) * 150; player.y += Math.sin(dashAngle) * 150; createParticleEffect(player.x, player.y, '#90ee90', { count: 20, speed: 2, life: 0.4 }); break;
                case 'Vanish': player.statusEffects.invisible = skill.duration; addLog(`You vanish for ${skill.duration} seconds!`); break;
                case 'Poison Blade': player.statusEffects.poisonBlade = skill.duration; addLog(`Your blades are coated with poison!`); break;
            }
        }
        
        function checkCollisions() {
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                if (rectsIntersect(player, item)) {
                    if (item.type === 'potion') { player.potions++; addLog('Picked up a potion!'); }
                    else if (item.type === 'gold') { player.gold += item.value; addLog(`Found ${item.value} gold!`); }
                    items.splice(i, 1);
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = `${TILE_SIZE * 0.8}px 'Press Start 2P'`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

            for (let y = 0; y < MAP_HEIGHT_TILES; y++) for (let x = 0; x < MAP_WIDTH_TILES; x++) { const tile = map.grid[y][x] === 1 ? SYMBOLS.wall : SYMBOLS.floor; ctx.fillStyle = tile.color; ctx.fillText(tile.char, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2); }

            const drawEntity = (entity, symbol) => { ctx.fillStyle = symbol.color; ctx.fillText(symbol.char, entity.x, entity.y); };
            items.forEach(item => drawEntity(item, SYMBOLS[item.type]));
            enemies.forEach(enemy => { if(enemy.statusEffects.stunned > 0) ctx.fillStyle='yellow'; else ctx.fillStyle=enemy.symbol.color; ctx.fillText(enemy.symbol.char, enemy.x, enemy.y); });
            projectiles.forEach(p => { ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.w/2, 0, Math.PI*2); ctx.fill(); });
            
            if (player.statusEffects.invisible > 0) ctx.globalAlpha = 0.5;
            ctx.fillText(SYMBOLS.player[player.className], player.x + player.w / 2, player.y + player.h / 2);
            ctx.globalAlpha = 1.0;

            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / p.maxLife; // Fade out
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0; // Reset alpha
        }
        
        function updateUI() {
            document.getElementById('player-class').innerText = player.className;
            document.getElementById('player-level').innerText = player.level;
            document.getElementById('dungeon-level').innerText = dungeonLevel;
            document.getElementById('hp-value').innerText = Math.max(0, Math.round(player.hp));
            document.getElementById('max-hp-value').innerText = player.maxHp;
            document.getElementById('hp-bar').style.width = `${(player.hp / player.maxHp) * 100}%`;
            document.getElementById('xp-value').innerText = player.xp; document.getElementById('xp-next-value').innerText = player.xpToNextLevel;
            document.getElementById('xp-bar').style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;
            
            const totalArmorDefense = player.armor ? player.armor.baseDefense : 0;
            const totalDefense = player.defense + totalArmorDefense;
            document.getElementById('attack-stat').innerText = player.attack; 
            document.getElementById('defense-stat').innerText = `${totalDefense} (${player.defense} + ${totalArmorDefense})`;
            
            document.getElementById('gold-value').innerText = player.gold; 
            document.getElementById('potions-value').innerText = player.potions;
            
            document.getElementById('weapon-name').innerText = player.weapon.name;
            document.getElementById('weapon-damage').innerText = `Dmg: ${player.weapon.baseDamage}`;
            document.getElementById('armor-name').innerText = player.armor ? player.armor.name : 'Rags';
            document.getElementById('armor-defense').innerText = `Def: ${totalArmorDefense}`;
            
            // Specialty Info
            const specialtyContainer = document.getElementById('specialty-info-container');
            const specialtyInfo = document.getElementById('specialty-info');
            let specialtyText = '';
            if (player.className === 'Warrior' && player.weapon.type === 'Axe') specialtyText = 'Axe: 25% chance to stun enemies.';
            else if (player.className === 'Mage' && player.weapon.type === 'Staff') specialtyText = 'Staff: +20% spell damage.';
            else if (player.className === 'Rogue' && player.weapon.type === 'Dagger') specialtyText = 'Dagger: Attacks cause bleeding.';
            
            if(specialtyText) {
                specialtyInfo.innerText = specialtyText;
                specialtyContainer.classList.remove('hidden');
            } else {
                specialtyContainer.classList.add('hidden');
            }

            const skillInfoEl = document.getElementById('skill-info');
            skillInfoEl.innerHTML = player.skills.map(skill => { const status = skill.currentCooldown > 0 ? `<span class="skill-cooldown">CD: ${skill.currentCooldown.toFixed(1)}s</span>` : `<span class="skill-ready">Ready</span>`; return `<p>${skill.key}: ${skill.name} - ${status}</p>`; }).join('');

            const logContainer = document.getElementById('log');
            if(gameLog.length > 0) logContainer.innerHTML = gameLog.slice(-10).map(msg => `<p>${msg}</p>`).join('');
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        function gainXP(amount) { player.xp += amount; addLog(`Gained ${amount} XP.`); if (player.xp >= player.xpToNextLevel) levelUp(); }
        function levelUp() { player.level++; player.xp -= player.xpToNextLevel; player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.5); let hpGain=0, attackGain=0, defenseGain=0; if (player.className === 'Warrior') { hpGain = 20; attackGain = 3; defenseGain = 2; } else if (player.className === 'Mage') { hpGain = 10; attackGain = 2; defenseGain = 1; } else { hpGain = 15; attackGain = 2; defenseGain = 2; } player.maxHp += hpGain; player.hp = player.maxHp; player.attack += attackGain; player.defense += defenseGain; player.skillPoints++; addLog(`LEVEL UP! You are level ${player.level} and gained a skill point!`); }
        function addLog(message) { if(gameLog[gameLog.length-1] !== message) { gameLog.push(message); if (gameLog.length > 50) gameLog.shift(); } }
        function distance(a, b) { return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2)); }
        function findNearestEnemy(range) { let closest = null, minDist = Infinity; enemies.forEach(e => { const d = distance(player, e); if (d < range && d < minDist) { minDist = d; closest = e; } }); return closest; }
        
        function createParticleEffect(x, y, color, { count = 20, speed = 4, life = 0.5, size = 3 } = {}) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.random()) * 2 * Math.PI; 
                const finalSpeed = speed * (0.7 + Math.random() * 0.6);
                particles.push({ x, y, vx: Math.cos(angle) * finalSpeed, vy: Math.sin(angle) * finalSpeed, life: life * (0.8 + Math.random() * 0.4), maxLife: life, size: size * (0.8 + Math.random() * 0.4), color: color, });
            }
        }
        function updateParticles(dt) {
             for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx; p.y += p.vy;
                p.vx *= 0.96; p.vy *= 0.96;
                p.life -= dt;
                if (p.life <= 0) { particles.splice(i, 1); }
            }
        }
        
        function gameLoop(currentTime) { 
            if(player && player.hp <= 0) return; 
            if (isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }
            const dt = (currentTime - lastTime) / 1000; 
            lastTime = currentTime; 
            update(dt); 
            draw(); 
            requestAnimationFrame(gameLoop); 
        }

        function showLevelClearScreen() {
            isPaused = true;
            document.getElementById('level-clear-screen').classList.remove('hidden');
            document.getElementById('next-floor-number').innerText = dungeonLevel + 1;

            // Populate Skills
            const skillOptions = document.getElementById('skill-unlock-options');
            skillOptions.innerHTML = '';
            document.getElementById('skill-points-value').innerText = player.skillPoints;
            if(player.skillTree.length > 0) {
                 player.skillTree.forEach(skill => {
                    const skillEl = document.createElement('div');
                    skillEl.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="text-yellow-400">${skill.name}</h4>
                                <p class="text-xs text-gray-400">${skill.description}</p>
                            </div>
                            <button class="btn btn-unlock">Unlock (1)</button>
                        </div>
                    `;
                    const btn = skillEl.querySelector('button');
                    if (player.skillPoints < 1) {
                        btn.disabled = true;
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                    btn.onclick = () => {
                        player.skillPoints--;
                        player.skills.push({...skill, currentCooldown: 0});
                        player.skillTree = player.skillTree.filter(s => s.name !== skill.name);
                        addLog(`You learned ${skill.name}!`);
                        showLevelClearScreen(); // Refresh screen
                        updateUI();
                    };
                    skillOptions.appendChild(skillEl);
                });
            } else {
                skillOptions.innerHTML = '<p class="text-gray-400 text-center">All skills learned!</p>';
            }

            // Populate Shop
            const shopOptions = document.getElementById('shop-item-options');
            shopOptions.innerHTML = '';
            document.getElementById('shop-gold-value').innerText = player.gold;
            const shopItems = [];
            const allItems = {...WEAPONS, ...ARMOR};
            const itemKeys = Object.keys(allItems);
            for(let i=0; i < 3; i++){ // Offer 3 random items
                const randomKey = itemKeys[Math.floor(Math.random() * itemKeys.length)];
                shopItems.push(JSON.parse(JSON.stringify(allItems[randomKey])));
            }
            
            shopItems.forEach(item => {
                const itemEl = document.createElement('div');
                 itemEl.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="text-green-400">${item.name}</h4>
                            <p class="text-xs text-gray-400">${item.type === 'Armor' ? 'Defense: ' + item.baseDefense : 'Damage: ' + item.baseDamage}</p>
                        </div>
                        <button class="btn btn-buy">Buy (${item.cost}g)</button>
                    </div>
                `;
                const btn = itemEl.querySelector('button');
                if (player.gold < item.cost) {
                    btn.disabled = true;
                    btn.classList.add('opacity-50', 'cursor-not-allowed');
                }
                btn.onclick = () => {
                    player.gold -= item.cost;
                    player.inventory.push(item);
                    addLog(`You purchased ${item.name}.`);
                    showLevelClearScreen(); // Refresh screen
                };
                shopOptions.appendChild(itemEl);
            });
        }
        
        function openInventory() {
            if (isPaused) return;
            isPaused = true;
            document.getElementById('inventory-screen').classList.remove('hidden');
            
            document.getElementById('inv-weapon-name').innerText = player.weapon.name;
            document.getElementById('inv-armor-name').innerText = player.armor ? player.armor.name : 'None';
            
            const inventoryList = document.getElementById('inventory-list');
            inventoryList.innerHTML = '';
            if (player.inventory.length === 0) {
                inventoryList.innerHTML = '<p class="text-gray-400">Backpack is empty.</p>';
            } else {
                player.inventory.forEach((item, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'flex justify-between items-center p-1';
                    const itemName = item.name;
                    itemEl.innerHTML = `<span>${itemName}</span><button class="btn btn-equip" data-index="${index}">Equip</button>`;
                    inventoryList.appendChild(itemEl);
                });
                inventoryList.querySelectorAll('.btn-equip').forEach(button => {
                    button.onclick = (e) => {
                        const index = parseInt(e.target.dataset.index);
                        equipItem(index);
                    };
                });
            }
        }
        function closeInventory() {
            isPaused = false;
            lastTime = performance.now();
            document.getElementById('inventory-screen').classList.add('hidden');
        }

        function equipItem(inventoryIndex) {
            const itemToEquip = player.inventory[inventoryIndex];
            
            if (itemToEquip.type === 'Axe' || itemToEquip.type === 'Sword' || itemToEquip.type === 'Dagger' || itemToEquip.type === 'Staff') {
                player.inventory.splice(inventoryIndex, 1); 
                player.inventory.push(player.weapon); 
                player.weapon = itemToEquip; 
                addLog(`Equipped ${itemToEquip.name}.`);
            } else if (itemToEquip.type === 'Armor') {
                player.inventory.splice(inventoryIndex, 1);
                if (player.armor) {
                    player.inventory.push(player.armor);
                }
                player.armor = itemToEquip;
                 addLog(`Equipped ${itemToEquip.name}.`);
            }
            openInventory(); // Refresh inventory screen
            updateUI();
        }

        function gameOver() { document.getElementById('game-over-screen').classList.remove('hidden'); document.getElementById('final-level').innerText = dungeonLevel; }
        function restartGame() { location.reload(); }

        document.getElementById('select-warrior').onclick = () => initGame('Warrior'); 
        document.getElementById('select-mage').onclick = () => initGame('Mage'); 
        document.getElementById('select-rogue').onclick = () => initGame('Rogue');
        document.getElementById('restart-button').onclick = restartGame; 
        document.getElementById('close-inventory').onclick = closeInventory;
        document.getElementById('next-level-button').onclick = () => {
            document.getElementById('level-clear-screen').classList.add('hidden');
            dungeonLevel++;
            startLevel();
        };

        window.addEventListener('keydown', e => {keysDown[e.key] = true; if(e.key==='p' && !isPaused) usePotion(); if(e.key ==='i') { if(document.getElementById('inventory-screen').classList.contains('hidden')) openInventory(); else closeInventory();} });
        window.addEventListener('keyup', e => delete keysDown[e.key]);

        function usePotion() { if(player && player.potions > 0) { player.hp = Math.min(player.maxHp, player.hp + player.maxHp * 0.4); player.potions--; addLog(`You drink a potion and restore health.`); } }
    </script>
</body>
</html>

